#!/bin/sh
# =============================================================================
# Git Wrapper: Branch Checkout Guard (Layer 1)
#
# Prevents branch checkout/switch in the main working tree.
# Injected into spawned agent environments via PATH prepending.
#
# Rules:
#   - checkout/switch in main tree -> BLOCKED (exit 128)
#   - checkout main (recovery) -> allowed
#   - file restore (-- prefix) -> allowed
#   - worktree (.git is a file) -> allowed
#   - everything else (log, status, diff, etc.) -> passthrough
#
# SECURITY: This file should be root-owned via protect-framework.sh
# =============================================================================

# Find the real git by searching PATH entries that aren't our wrapper dir
SELF_DIR="$(cd "$(dirname "$0")" && pwd -P)"
REAL_GIT=""
OLD_IFS="$IFS"
IFS=':'
for dir in $PATH; do
  case "$dir" in
    "$SELF_DIR") continue ;;
  esac
  if [ -x "$dir/git" ]; then
    REAL_GIT="$dir/git"
    break
  fi
done
IFS="$OLD_IFS"

if [ -z "$REAL_GIT" ]; then
  echo "FATAL: Cannot find real git binary" >&2
  exit 127
fi

# Fast path: no arguments at all
if [ $# -eq 0 ]; then
  exec "$REAL_GIT"
fi

# Extract the git subcommand (skip global flags like -C, -c, --git-dir, etc.)
SUBCMD=""
i=0
skip_next=0
for arg in "$@"; do
  if [ "$skip_next" = "1" ]; then
    skip_next=0
    continue
  fi
  case "$arg" in
    -C|-c|--git-dir|--work-tree|--namespace)
      skip_next=1
      continue
      ;;
    --git-dir=*|--work-tree=*|--namespace=*|-C*)
      continue
      ;;
    --bare|--no-pager|--no-replace-objects|--literal-pathspecs|--glob-pathspecs|--noglob-pathspecs|--no-optional-locks)
      continue
      ;;
    -*)
      continue
      ;;
    *)
      SUBCMD="$arg"
      break
      ;;
  esac
done

# Fast path: not checkout or switch -> passthrough (zero overhead)
case "$SUBCMD" in
  checkout|switch) ;;
  *) exec "$REAL_GIT" "$@" ;;
esac

# Check if we're in a worktree (.git is a file, not a directory)
if [ -f ".git" ]; then
  # Worktree — everything allowed
  exec "$REAL_GIT" "$@"
fi

# Check if we're in a git repo at all
if [ ! -d ".git" ]; then
  # Not a repo — passthrough
  exec "$REAL_GIT" "$@"
fi

# We're in the main working tree with checkout/switch. Parse args.
has_dash_dash=0
has_create_flag=0
target_branch=""

# Re-parse: skip the subcommand itself, collect remaining args
past_subcmd=0
for arg in "$@"; do
  if [ "$past_subcmd" = "0" ]; then
    # Skip until we find the subcommand
    case "$arg" in
      -C|-c|--git-dir|--work-tree|--namespace)
        skip_next=1
        continue
        ;;
    esac
    if [ "$skip_next" = "1" ]; then
      skip_next=0
      continue
    fi
    case "$arg" in
      --git-dir=*|--work-tree=*|--namespace=*|-C*)
        continue
        ;;
      --bare|--no-pager|--no-replace-objects|--literal-pathspecs|--glob-pathspecs|--noglob-pathspecs|--no-optional-locks)
        continue
        ;;
      checkout|switch)
        past_subcmd=1
        continue
        ;;
    esac
    continue
  fi

  # Now parsing checkout/switch args
  case "$arg" in
    --)
      has_dash_dash=1
      ;;
    -b|-B|--create|--force-create|-c)
      has_create_flag=1
      ;;
    -b*|-B*)
      # -b<branch> combined form
      has_create_flag=1
      target_branch="${arg#-?}"
      ;;
    -*)
      # Other flags (--force, --detach, etc.)
      ;;
    *)
      # Positional argument = branch name or file
      if [ -z "$target_branch" ]; then
        target_branch="$arg"
      fi
      ;;
  esac
done

# Rule: file restore (-- present) -> allow
if [ "$has_dash_dash" = "1" ]; then
  exec "$REAL_GIT" "$@"
fi

# Rule: checkout main (recovery path) -> allow
if [ "$target_branch" = "main" ]; then
  exec "$REAL_GIT" "$@"
fi

# Rule: no target and no create flag -> harmless (e.g. bare "git checkout")
if [ -z "$target_branch" ] && [ "$has_create_flag" = "0" ]; then
  exec "$REAL_GIT" "$@"
fi

# BLOCK: branch change in main working tree
cat >&2 <<'BLOCKED_MSG'
BLOCKED: Branch checkout in main working tree.
  The main tree must stay on 'main' to prevent drift.
  You are working in the main tree — use a worktree for feature work.
  Worktrees are created automatically by the task runner.
  To recover: 'git checkout main' is always allowed.
BLOCKED_MSG
exit 128
